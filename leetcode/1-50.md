#  哈希表 1

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 \
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 \
你可以按任意顺序返回答案。 

示例 1： \
输入：nums = [2,7,11,15], target = 9 \
输出：[0,1] \
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2： \
输入：nums = [3,2,4], target = 6 \
输出：[1,2] \

示例 3： \
输入：nums = [3,3], target = 6 \
输出：[0,1]

思路，利用哈希表的特点，多个键值对应一个值，可以将整数作为键值，数组下标作为数值存储在哈希表中，通过查找target-整数 是否存在与这个表中，确认序号。
```
/* Hash table structure --------------------------------------------------------
* Used to store key-value pairs for fast lookup and insertion.
* key : key of the hash table (element value)
* val : value of the hash table (element index)
* hh  : uthash handle
*---------------------------------------------------------------------------*/
struct hashTable {
    int key;
    int val;
    UT_hash_handle hh;
};
struct hashTable* hashtable;

/* Find element in hash table --------------------------------------------------
* Find an element in the hash table by key.
* args   : int ikey         I   key to find
* return : pointer to found element (NULL if not found)
*---------------------------------------------------------------------------*/
struct hashTable* find(int ikey) {
    struct hashTable* tmp;
    HASH_FIND_INT(hashtable, &ikey, tmp);
    return tmp;
}

/* Insert element into hash table ----------------------------------------------
* Insert a key-value pair into the hash table, update value if key exists.
* args   : int ikey         I   key to insert
*          int ival         I   value to insert
* return : none
*---------------------------------------------------------------------------*/
void insert(int ikey, int ival) {
    struct hashTable* it = find(ikey);
    if (it == NULL) {
        struct hashTable* tmp = malloc(sizeof(struct hashTable));
        tmp->key = ikey, tmp->val = ival;
        HASH_ADD_INT(hashtable, key, tmp);
    } else {
        it->val = ival;
    }
}

/* Two Sum main function -------------------------------------------------------
* Find two numbers in the array that add up to target and return their indices.
* args   : int* nums        I   input array
*          int numsSize     I   array length
*          int target       I   target sum
*          int* returnSize  O   length of result array
* return : array of indices (length 2), NULL if not found
*---------------------------------------------------------------------------*/
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    hashtable = NULL;
    for (int i = 0; i < numsSize; i++) {
        struct hashTable* it = find(target - nums[i]);
        if (it != NULL) {
            int* ret = malloc(sizeof(int) * 2);
            ret[0] = it->val, ret[1] = i;
            *returnSize = 2;
            return ret;
        }
        insert(nums[i], i);
    }
    *returnSize = 0；
    return NULL;
} 
```




#  哈希表 2
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

示例 1: \
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"] \
输出: [["bat"],["nat","tan"],["ate","eat","tea"]] \
解释： \
在 strs 中没有字符串可以通过重新排列来形成 "bat"。 \
字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此。 \
字符串 "ate" ，"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此。 

示例 2: \
输入: strs = [""] \
输出: [[""]] 

示例 3: \
输入: strs = ["a"] \
输出: [["a"]]

思路，异位词的本质特征是字母异位词（如 "eat"、"tea"、"ate"）包含相同的字母，只是排列顺序不同。 \
将每个字符串按字母排序后，异位词会变成相同的字符串（如 "aet"）。 \
使用排序后的字符串作为分组标识，通过哈希表将相同标识的字符串归入同一组。 
```
struct hashTable {
    char key[256];        
    int groupIndex;      
    UT_hash_handle hh;  
};


int cmpChar(const void* a, const void* b) {
    return (*(char*)a - *(char*)b);
}


char*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes) {
    *returnSize = 0;
    if (strsSize == 0) {
        return NULL;
    }


    struct hashTable* hashMap = NULL;
    char*** result = (char***)malloc(strsSize * sizeof(char**));
    *returnColumnSizes = (int*)malloc(strsSize * sizeof(int));
    int* groupSizes = (int*)calloc(strsSize, sizeof(int)); 

    for (int i = 0; i < strsSize; i++) {

        int len = strlen(strs[i]);
        char sortedStr[256] = {0};
        strcpy(sortedStr, strs[i]);
        qsort(sortedStr, len, sizeof(char), cmpChar);

        struct hashTable* findKey = NULL;
        HASH_FIND_STR(hashMap, sortedStr, findKey);

        if (findKey == NULL) {
            struct hashTable* newKey = (struct hashTable*)malloc(sizeof(struct hashTable));
            strcpy(newKey->key, sortedStr);
            newKey->groupIndex = *returnSize;
            HASH_ADD_STR(hashMap, key, newKey);

            result[*returnSize] = (char**)malloc(strsSize * sizeof(char*));
            result[*returnSize][0] = strs[i];
            groupSizes[*returnSize] = 1;
            (*returnColumnSizes)[*returnSize] = 1;
            (*returnSize)++;
        } else {
            int groupIdx = findKey->groupIndex;
            result[groupIdx][groupSizes[groupIdx]] = strs[i];
            groupSizes[groupIdx]++;
            (*returnColumnSizes)[groupIdx] = groupSizes[groupIdx];
        }
    }

    struct hashTable *current, *tmp;
    HASH_ITER(hh, hashMap, current, tmp) {
        HASH_DEL(hashMap, current);
        free(current);
    }
    free(groupSizes);

    return result;
}
```

#  哈希表 3

利用哈希表实现 O(1) 查找：将所有数字存入哈希表，实现快速查找 \
避免重复处理：只从连续序列的起点开始扩展，确保每个序列只被处理一次 \
双向扩展序列：对于每个起点，同时向左（更小数字）和向右（更大数字）扩展序列

```
typedef struct {
    int key;                
    int used;               
    UT_hash_handle hh;      
} HashTable;


int findInHash(HashTable **hash, int num) {
    HashTable *item = NULL;
    HASH_FIND_INT(*hash, &num, item);
    return item != NULL;
}

int longestConsecutive(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0;
    }

    HashTable *hash = NULL;
    int maxLength = 0;

    for (int i = 0; i < numsSize; i++) {
        HashTable *item = NULL;
        HASH_FIND_INT(hash, &nums[i], item);
        if (!item) {
            item = (HashTable*)malloc(sizeof(HashTable));
            item->key = nums[i];
            item->used = 0;
            HASH_ADD_INT(hash, key, item);
        }
    }


    HashTable *current, *tmp;
    HASH_ITER(hh, hash, current, tmp) {
        if (current->used) continue;
        current->used = 1;
        
        int currentNum = current->key;
        int currentLength = 1;
        
        int left = currentNum - 1;
        while (findInHash(&hash, left)) {
            HashTable *leftItem = NULL;
            HASH_FIND_INT(hash, &left, leftItem);
            leftItem->used = 1;
            currentLength++;
            left--;
        }
        
        int right = currentNum + 1;
        while (findInHash(&hash, right)) {
            HashTable *rightItem = NULL;
            HASH_FIND_INT(hash, &right, rightItem);
            rightItem->used = 1;
            currentLength++;
            right++;
        }
        

        if (currentLength > maxLength) {
            maxLength = currentLength;
        }
    }

    HASH_ITER(hh, hash, current, tmp) {
        HASH_DEL(hash, current);
        free(current);
    }

    return maxLength;
}
```